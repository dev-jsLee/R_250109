# 매트릭스(matrix)
# 매트릭스는 동일한 자료형의 데이터가 2차원 배열로
# 저장하는 자료구조다.
# 행(row)과 열(column)으로 구성된 배열이다.
# 모든 요소가 동일한 자료형이어야 한다는 것은 벡터와 유사하다.
# 매트릭스의 생성
# matrix()함수를 사용하여 생성할 수 있다.
# 각 값은 열 방향으로 채워지는 것이 기본값이다.
# matrix(data=값이 담긴 벡터, nrow=행의길이, ncol=열의길이)
mat_1 <- matrix(1:12, 3, 4)
print(mat_1)
# 
R version 4.4.2 (2024-10-31 ucrt) -- "Pile of Leaves"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64

R은 자유 소프트웨어이며, 어떠한 형태의 보증없이 배포됩니다.
또한, 일정한 조건하에서 이것을 재배포 할 수 있습니다.
배포와 관련된 상세한 내용은 'license()' 또는 'licence()'을 통하여 확인할 수 있습니다.

R은 많은 기여자들이 참여하는 공동프로젝트입니다.
'contributors()'라고 입력하시면 이에 대한 더 많은 정보를 확인하실 수 있습니다.
그리고, R 또는 R 패키지들을 출판물에 인용하는 방법에 대해서는 'citation()'을 통해 확인하시길 부탁드립니다.

'demo()'를 입력하신다면 몇가지 데모를 보실 수 있으며, 'help()'를 입력하시면 온라인 도움말을 이용하실 수 있습니다.
또한, 'help.start()'의 입력을 통하여 HTML 브라우저에 의한 도움말을 사용하실수 있습니다
R의 종료를 원하시면 'q()'을 입력해주세요.

[Workspace loaded from E:/r_1900_ljs_250109/workspace/r_practice/.RData]

> # 벡터
  > # 벡터는 같은 자료형의 값들을 요소로 가지는
  > # 1차원 배열을 의미한다.
  > # 벡터 만드는 방법
  > # c(값1, 값2, 값3,...)
  > # 위와 같이 콤마,를 이용해 값과 값을 구분하여
  > # 소괄호()에 전달하면 벡터로 만들어진다.
  > vec_1 <- c(1, 2, 3)
> # 벡터
  > # 벡터는 같은 자료형의 값들을 요소로 가지는
  > # 1차원 배열을 의미한다.
  > # 벡터 만드는 방법
  > # c(값1, 값2, 값3,...)
  > # 위와 같이 콤마,를 이용해 값과 값을 구분하여
  > # 소괄호()에 전달하면 벡터로 만들어진다.
  > vec_1 <- c(3, 21, 32)
> print(vec_1)
[1]  3 21 32
> # 벡터의 요소에 접근하는 방법
  > # 변수명[인덱스]
  > # 변수명에는 벡터가 담겨있어야 하며
  > # 인덱스란, 정수값으로 1부터 세는 순서 값을 넣어주면 된다.
  > # 예) vec_1의 1번째 값인 3을 가져오고자 한다면
  > print(vec_1[1])
[1] 3
> print("길")
[1] "길"
> # 문자형 벡터를 만들어보자.
  > # '홍', '길', '동'
  > vec_char <- c('홍', '길', '동')
> print(vec_char[2]) # '길'을 출력해보자.
[1] "길"
> # 논리형 벡터를 만들어보자.
  > vec_logic <- c(T, T, F, T, F, F)
> # 1번째 값과 4번째 값을 더하여 2를 출력해보자.
  > print(vec_logic[1] + vec_logic[4])
[1] 2
> # 새로 벡터를 덮어씌우자.
  > vec_1 <- c(1, 3, 5, 2, 6, 4)
> # 2번째 값 대신 5번째 값을 넣고
  > vec_1[2] <- vec_1[5]
> print(vec_1)
[1] 1 6 5 2 6 4
> # 5번째 값 대신 5번째 값의 반절을 넣어보자.
  > vec_1[5] <- vec_1[5] / 2
> print(vec_1) # 1 6 5 2 6 4
[1] 1 6 5 2 3 4
> # 서로 다른 자료형을 벡터로 만들 경우
  > # 가장 큰 범위를 가지는 자료형으로 모두 형변환된다.
  > vec_diff <- c(1, 3.14, T)
> print(vec_diff)
[1] 1.00 3.14 1.00
> # 서로 다른 자료형을 벡터로 만들 경우
  > # 가장 큰 범위를 가지는 자료형으로 모두 형변환된다.
  > vec_diff <- c(1, 3.145, T)
> print(vec_diff)
[1] 1.000 3.145 1.000
> class("")
[1] "character"
> # 벡터를 만드는 함수들
  > # rep(값, 반복횟수)
  > # 전달된 값을 반복횟수만큼 반복한 벡터가 생성된다.
  > vec_rep1 <- rep(3, 10)
> print(vec_rep1)
[1] 3 3 3 3 3 3 3 3 3 3
> # 이때 전달되는 값이 벡터라면
  > # 전달된 벡터 각각을 반복횟수만큼 반복하여
  > # 모두 합쳐서 하나의 벡터로 만든다.
  > vec_rep2 <- rep(c(1, 2, 3), 3) # 1 1 1 2 2 2 3 3 3
> print(vec_rep2)
[1] 1 2 3 1 2 3 1 2 3
> # each 옵션이 있는 경우
  > # 앞선 요소를 모두 반복한 뒤 다음 요소를 반복
  > vec_rep3 <- rep(c(1, 2, 3), each=3)
> print(vec_rep3)
[1] 1 1 1 2 2 2 3 3 3
> # 등차수열을 만드는 벡터 생성 함수
  > # seq(start, end, step)
  > vec_seq <- seq(1, 100, 5)
> print(vec_seq)
[1]  1  6 11 16 21 26 31 36 41 46
[11] 51 56 61 66 71 76 81 86 91 96
> # 1, 6, 11,...,91, 96
  > vec_seq2 <- seq(100, 50, -5)
> print(vec_seq2)
[1] 100  95  90  85  80  75  70
[8]  65  60  55  50
> # 자료형과 길이를 정해서 만드는 벡터
  > # 자료형(length=길이)
  > # 해당 자료형의 기본값으로 길이만큼의 벡터를 생성
  > # 정수형으로 10개가 담기는 벡터 생성
  > vec_int <- integer(length=10) # 0 0 0 0 0 0 0 0 0 0
> print(vec_int)
[1] 0 0 0 0 0 0 0 0 0 0
> vec_float <- float(10)
float(10)에서 다음과 같은 에러가 발생했습니다: 함수 "float"를 찾을 수 없습니다
> vec_float <- double(10)
> vec_double <- double(10)
> print(vec_double)
[1] 0 0 0 0 0 0 0 0 0 0
> # 그외 numeric, character 등이 있다.
  > vec_logic2 <- logical(3)
> print(vec_logic2)
[1] FALSE FALSE FALSE
> # 벡터의 각 요소에 이름을 붙여 생성할 수도 있다.
  > named_vec <- c(num1=1, num2=2, num3=7)
> print(named_vec)
num1 num2 num3 
1    2    7 
> # 벡터의 각 요소에 이름을 붙여 생성할 수도 있다.
  > named_vec <- c(1, num2=2, num3=7)
> print(named_vec)
num2 num3 
1    2    7 
> # 벡터의 각 요소에 이름을 붙여 생성할 수도 있다.
  > named_vec <- c(num1=1, 2, num3=7)
> print(named_vec)
num1      num3 
1    2    7 
> # 벡터의 각 요소에 이름을 붙여 생성할 수도 있다.
  > named_vec <- c(num1=1, num2=2, num3=7)
> print(named_vec)
num1 num2 num3 
1    2    7 
> # 벡터의 요소에 이름을 붙이면
  > # 붙인 그 이름으로도 접근할 수 있다.
  > # :접근 => 값을 사용하거나 변경할 수 있다.
  > print(named_vec["num1"])
num1 
1 
> # 벡터의 요소에 이름을 붙이면
  > # 붙인 그 이름으로도 접근할 수 있다.
  > # :접근 => 값을 사용하거나 변경할 수 있다.
  > print(named_vec["num1"]+1)
num1 
2 
> print(named_vec["num1"])
num1 
1 
> # 벡터의 요소에 이름을 붙이면
  > # 붙인 그 이름으로도 접근할 수 있다.
  > # :접근 => 값을 사용하거나 변경할 수 있다.
  > print(named_vec["num1"]+1)
num1 
2 
> named_vec["num3"] <- 71
> print(named_vec[3])
num3 
71 
> # 벡터의 여러 값을 들고 오고 싶을 때는
  > # 대괄호[]에 벡터를 전달하면 된다.
  > vec_num1 <- c(10, 20, 30)
> print(vec_num1[c(1, 2)])
[1] 10 20
> print(vec_num1[c(1, 3)])
[1] 10 30
> # 콜론:의 앞뒤로 숫자를 넣으면
  > # 등차 1인 등차수열을 만들 수 있다.
  > # start:end
  > # start부터 end
  > print(1:10)
[1]  1  2  3  4  5  6  7  8  9 10
> vec_seq3 <- 10:31
> print(vec_seq3[3:10])
[1] 12 13 14 15 16 17 18 19
> # 벡터의 연산
  > vec_1 <- 1:3
> vec_2 <- 4:6
> # 덧셈
  > vec_sum <- vec_1 + vec_2
> print(vec_sum)
[1] 5 7 9
> # 뺄셈
  > vec_minus <- vec_1 - vec_2
> print(vec_minus)
[1] -3 -3 -3
> print(vec_sum)
[1] 5 7 9
> print(vec_minus) # 
[1] -3 -3 -3
> # 곱셈
  > vec_multi <- vec_1 * vec_2
> print(vec_multi)
[1]  4 10 18
> # 나눗셈
  > # 나눗셈의 우항이 0이 되지 않도록 조심하자.
  > vec_divide <- vec_1 / vec_2
> print(vec_divide)
[1] 0.25 0.40 0.50
> # 기타
  > # 길이가 다른 두 벡터의 연산
  > vec_1 <- 1:5
> vec_2 <- 1:10
> print(vec_1 + vec_2)
[1]  2  4  6  8 10  7  9 11 13 15
> # 기타
  > # 길이가 다른 두 벡터의 연산
  > vec_1 <- 1:4
> vec_2 <- 1:10
> print(vec_1 + vec_2)
[1]  2  4  6  8  6  8 10 12 10 12
경고메시지(들):
  vec_1 + vec_2에서: 두 객체의 길이가 서로 배수관계에 있지 않습니다
> # 기타
  > # 길이가 다른 두 벡터의 연산
  > # 길이가 다른 두 벡터가 연산할 경우
  > # 두 벡터의 길이가 배수관계이면 오류 없이
  > # 길이가 적은 쪽이 반복하여 사용된다.
  > # 길이가 배수관계 아니라면
  > # 결과는 나오지만 경고 메시지도 같이 나온다.
  > vec_1 <- 1:5
> vec_2 <- 1:10
> print(vec_1 + vec_2)
[1]  2  4  6  8 10  7  9 11 13 15
> # 매트릭스(matrix)
  > # 매트릭스는 동일한 자료형의 데이터가 2차원 배열로
  > # 저장하는 자료구조다.
  > # 행(row)과 열(column)으로 구성된 배열이다.
  > # 모든 요소가 동일한 자료형이어야 한다는 것은 벡터와 유사하다.
  > # 매트릭스의 생성
  > # matrix()함수를 사용하여 생성할 수 있다.
  > # 각 값은 열 방향으로 채워지는 것이 기본값이다.
  > # matrix(data=값이 담긴 벡터, nrow=행의길이, ncol=열의길이)
  > mat_1 <- matrix(1:12, 3, 4)
> print(mat_1)
#       [,1] [,2] [,3] [,4]
# [1,]    1    4    7   10
# [2,]    2    5    8   11
# [3,]    3    6    9   12

# 데이터를 매트릭스에 배치하는 방향을 행 방향으로 바꿀 수 있다.
mat_2 <- matrix(1:12, 3, 4, byrow=T)
print(mat_2)
#       [,1] [,2] [,3] [,4]
# [1,]    1    2    3    4
# [2,]    5    6    7    8
# [3,]    9   10   11   12

# 행렬의 요소에 접근하는 방법
# 1. 행을 가져오기
print(mat_2[2,]) # 5 6 7 8
print(mat_2[3]) # 벡터에 접근할 때
# 반점,없이 인덱스를 전달하면
# 해당 인덱스 행의 첫번째 요소를 가져온다.
# 2. 열을 가져오기
print(mat_2[,2]) # 2 6 10
# 2열부터 4열까지 가져오기?
print(mat_2[,2:4]) # 열값이 들어갈 곳에 벡터를 전달
#      [,1] [,2] [,3]
# [1,]    2    3    4
# [2,]    6    7    8
# [3,]   10   11   12

# 도전!
# mat_2 행렬을
# 2행부터 3행까지, 2열부터 4열까지의 총 6개 요소를
# 가져와보자.
print(mat_2[2:3,2:4])
#      [,1] [,2] [,3]
# [1,]    6    7    8
# [2,]   10   11   12

# 1행과 3행, 2열과 4열
print(mat_2[c(1,3), c(2,4)])
#      [,1] [,2]
# [1,]    2    4
# [2,]   10   12